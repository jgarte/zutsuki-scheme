%{
    const is_node = typeof require !== "undefined";
    if (is_node){
        module.exports = ZLexer;
        var Zutsuki = require("./zutsuki");
    }

%}


%zoption zlib ZLexer


SYMBOL ([a-zA-Z]|[0-9]|[-!$%&*+./:<=>?@^_~])+
BOOLEAN #true|#false|#t|#f

HEX_SCALAR_VALUE ([0-9]|[a-f])+
CHARACTER_NAME alarm|backspace|delete|escape|newline|null|return|space|tab
CHAR (#\\{CHARACTER_NAME}|#\\x{HEX_SCALAR_VALUE}|#\\.)

STRING \".*\"

NORMAL_COMMENT ;.*\n
NESTED_COMMENT #\|(.|\n)*\|#
COMMENT ({NORMAL_COMMENT}|{NESTED_COMMENT})

UINTEGER [0-9]+
NUMBER {UINTEGER}


%%

(\ |\t) {
    console.log("SP");
}

\n {
    console.log("NL");
}

#\( {
    console.log("VECTOR-LP");
    return "#(";
}

\( {
    console.log("LP");   
    return "(";
}

\) {
    console.log("RP");
    return ")";
}

\. {
    console.log("DOT");   
    return ".";
}


\' {
    console.log("QUOTE");
    return "'";
}

\` {
    console.log("QQ");
    return "`";
}

,@ {
    console.log("UNQUOTE SPLICING");   
    return ",@";
}

, {
    console.log("UNQUOTE");
    return ",";
}

{NUMBER} {
    console.log("NUMBER",ztext,zline);
    return new Zutsuki.Number(ztext,Zutsuki.NUMBER_TYPE_UNSIGNED_INTEGER);
}

{SYMBOL} {
    console.log("SYMBOL",ztext,zline);   
    return new Zutsuki.Symbol(ztext,zline,"FILE");
}

{BOOLEAN} {
    console.log("BOOLEAN",ztext,zline);
    return new Zutsuki.Boolean(ztext);
}

{CHAR} {
    console.log("CHAR",ztext,zline);
    return new Zutsuki.Char(ztext);
}

{STRING} {
    console.log("STRING",ztext,zline);
}


{COMMENT} {
    console.log("COMMENT");
}




#{UINTEGER} {
    console.log("DATUM LABEL",ztext);
    return new Zutsuki.Datum_label(parseInt(ztext.substr(1)));
}

# {
    return "#";
}


%%



